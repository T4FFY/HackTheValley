import React, { useCallback, useMemo, useRef, useState } from "react";

/* ------------------------ Config ------------------------ */
const DEFAULT_ROBOT_URL = "http://192.168.4.1";
const GAP_MS = 150;
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

const NOTE_OPTIONS = [
  "C3","D3","E3","F3","G3","A3","B3",
  "C4","D4","E4","F4","G4","A4","B4",
  "C5","D5","E5","F5","G5","A5","B5",
  "C6","D6","E6","F6","G6",
];

const COLORS = {
  motion:  "#4CAF50",
  sound:   "#E91E63",
  display: "#FF9800",
  control: "#673AB7",
  fx:      "#06B6D4",
};

let uid = 1;
const newId = () => String(uid++);

/* ------------------------ Helpers ------------------------ */
function clamp255(v) {
  const n = Math.round(Number(v || 0));
  if (Number.isNaN(n)) return 0;
  return Math.min(255, Math.max(0, n));
}

/* A little block shell */
function BlockShell({ color, title, children, onUp, onDown, onDelete }) {
  return (
    <div style={{
      display: "grid",
      gridTemplateColumns: "12px 1fr auto",
      gap: 10,
      padding: 10,
      borderRadius: 12,
      background: "#fff",
      boxShadow: "0 8px 14px rgba(17,24,39,.08)",
      border: "1px solid rgba(0,0,0,.06)",
    }}>
      <div style={{
        background: color,
        borderRadius: 999,
        margin: "6px 0",
      }} />
      <div style={{minWidth: 0}}>
        <div style={{fontWeight: 800, color, marginBottom: 8}}>{title}</div>
        <div style={{display: "flex", gap: 10, flexWrap: "wrap"}}>{children}</div>
      </div>
      <div style={{display: "grid", gap: 6}}>
        <button onClick={onUp}    title="Move up"   style={btnIcon}>‚Üë</button>
        <button onClick={onDown}  title="Move down" style={btnIcon}>‚Üì</button>
        <button onClick={onDelete}title="Delete"    style={{...btnIcon, color:"#ef4444"}}>‚úï</button>
      </div>
    </div>
  );
}

const btnIcon = {
  background: "transparent",
  border: "1px solid #e5e7eb",
  borderRadius: 10,
  padding: "6px 8px",
  cursor: "pointer",
  fontWeight: 700,
};

/* Palette item styled like a mini block */
function PaletteItem({ label, color, onDragStart }) {
  return (
    <div
      draggable
      onDragStart={onDragStart}
      style={{
        userSelect: "none",
        padding: "12px 14px",
        borderRadius: 12,
        background: "#fff",
        border: "1px solid rgba(0,0,0,.06)",
        boxShadow: "0 6px 12px rgba(17,24,39,.06)",
        cursor: "grab",
        display: "grid",
        gridTemplateColumns: "10px 1fr",
        gap: 10,
        alignItems: "center",
      }}
    >
      <div style={{ background: color, height: 16, borderRadius: 999 }} />
      <div style={{ fontWeight: 700 }}>{label}</div>
    </div>
  );
}

/* Soft panel shell */
function Panel({ title, subtitle, children }) {
  return (
    <div style={{
      background: "linear-gradient(180deg, #f9fafb 0%, #ffffff 100%)",
      border: "1px solid rgba(0,0,0,.06)",
      borderRadius: 16,
      boxShadow: "0 10px 20px rgba(17,24,39,.06)",
      padding: 16
    }}>
      <div style={{fontWeight: 900, fontSize: 16}}>{title}</div>
      {subtitle && <div style={{opacity:.7, marginTop: 4, fontSize: 13}}>{subtitle}</div>}
      <div style={{marginTop: 12}}>{children}</div>
    </div>
  );
}

/* ------------------------ Main ------------------------ */
export default function SimpleDragAndRunPrettier() {
  const [robotUrl, setRobotUrl] = useState(DEFAULT_ROBOT_URL);
  const [items, setItems] = useState([]);
  const [running, setRunning] = useState(false);
  const [log, setLog] = useState("üëã Drag actions into the sequence, tweak values, then press Run.");

  // ----- Drag from palette -----
  const paletteDragStart = (e, type) => e.dataTransfer.setData("text/plain", type);

  const dropZoneRef = useRef(null);
  const onDragOver = (e) => e.preventDefault();
  const onDrop = (e) => {
    e.preventDefault();
    const type = e.dataTransfer.getData("text/plain");
    if (!type) return;
    const add = (obj) => setItems((prev) => [...prev, obj]);

    switch (type) {
      case "move":
        add({ id: newId(), type: "move", dir: "forward", seconds: 0.8 });
        break;
      case "beep":
        add({ id: newId(), type: "beep" });
        break;
      case "note":
        add({ id: newId(), type: "note", name: "C4", beats: 1 });
        break;
      case "mary":
        add({ id: newId(), type: "mary" });
        break;
      case "rgb":
        add({ id: newId(), type: "rgb", hex: "#00AEEF", r: 0, g: 128, b: 255 });
        break;
      case "lcd":
        add({
          id: newId(),
          type: "lcd",
          msg: "Hello Robot!",
          row: 0,
          align: "center",
          hex: "#00AEEF",
          r: 0, g: 128, b: 255,
        });
        break;
      case "wait":
        add({ id: newId(), type: "wait", seconds: 1 });
        break;
      case "rainbowStart":
        add({ id: newId(), type: "rainbowStart", interval: 40, sat: 255, val: 160 });
        break;
      case "rainbowStop":
        add({ id: newId(), type: "rainbowStop" });
        break;
      default:
        break;
    }
  };

  // ----- Update / reorder -----
  const updateItem = (id, patch) =>
    setItems((prev) => prev.map((it) => (it.id === id ? { ...it, ...patch } : it)));
  const removeItem = (id) => setItems((prev) => prev.filter((it) => it.id !== id));
  const moveUp = (i) => setItems((prev) => (i <= 0 ? prev : swap(prev, i, i - 1)));
  const moveDown = (i) => setItems((prev) => (i >= prev.length - 1 ? prev : swap(prev, i, i + 1)));
  const swap = (arr, i, j) => { const c=[...arr]; [c[i],c[j]]=[c[j],c[i]]; return c; };

  // ----- Runner -----
  const run = useCallback(async () => {
    if (!items.length || running) return;
    setRunning(true);
    setLog("üöÄ Executing‚Ä¶");

    const base = robotUrl.replace(/\/+$/, "");
    const stepLog = (t) => setLog((p) => p + "\n‚Ä¢ " + t);

    try {
      for (const it of items) {
        switch (it.type) {
          case "move": {
            const dir = (it.dir === "backward") ? "back" : "fwd";
            const ms = Math.max(0, Math.round(Number(it.seconds || 0.8) * 1000));
            const body = new URLSearchParams({ l: dir, r: dir, ms: String(ms) });
            stepLog(`POST ${base}/motor  body: ${body.toString()}`);
            await fetch(`${base}/motor`, { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body });
            break;
          }
          case "beep": {
            const url = `${base}/beep`;
            stepLog(`GET ${url}`);
            await fetch(url);
            break;
          }
          case "note": {
            const name = it.name || "C4";
            const beats = Math.max(0.1, Number(it.beats) || 1);
            const url = `${base}/note?name=${encodeURIComponent(name)}&beats=${encodeURIComponent(beats)}`;
            stepLog(`GET ${url}`);
            await fetch(url);
            break;
          }
          case "mary": {
            const url = `${base}/mary`;
            stepLog(`GET ${url}`);
            await fetch(url);
            break;
          }
          case "rgb": {
            const hasHex = it.hex && String(it.hex).trim().length >= 4;
            if (hasHex) {
              let hex = String(it.hex).trim();
              if (!hex.startsWith("#")) hex = "#" + hex;
              const body = new URLSearchParams({ hex });
              stepLog(`POST ${base}/rgb  body: ${body.toString()}`);
              await fetch(`${base}/rgb`, { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body });
            } else {
              const r = clamp255(it.r), g = clamp255(it.g), b = clamp255(it.b);
              const body = new URLSearchParams({ r: String(r), g: String(g), b: String(b) });
              stepLog(`POST ${base}/rgb  body: ${body.toString()}`);
              await fetch(`${base}/rgb`, { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body });
            }
            break;
          }
          case "lcd": {
            const p = new URLSearchParams();
            p.set("msg", it.msg || "");
            p.set("row", String(Math.min(1, Math.max(0, Number(it.row) || 0))));
            p.set("align", (it.align || "center").toLowerCase());
            const hasHex = it.hex && String(it.hex).trim().length >= 4;
            if (hasHex) {
              let hex = String(it.hex).trim();
              if (!hex.startsWith("#")) hex = "#" + hex;
              p.set("hex", hex);
            } else if (it.r !== undefined || it.g !== undefined || it.b !== undefined) {
              p.set("r", String(clamp255(it.r)));
              p.set("g", String(clamp255(it.g)));
              p.set("b", String(clamp255(it.b)));
            }
            stepLog(`POST ${base}/lcd  body: ${p.toString()}`);
            await fetch(`${base}/lcd`, { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body: p });
            break;
          }
          case "wait": {
            const ms = Math.max(0, Math.round(Number(it.seconds || 1) * 1000));
            stepLog(`WAIT ${ms}ms`);
            await sleep(ms);
            break;
          }
          case "rainbowStart": {
            const interval = Math.max(5, Math.min(1000, Number(it.interval) || 40));
            const sat = clamp255(it.sat);
            const val = clamp255(it.val);
            const url = `${base}/fx/rainbow/start?interval=${encodeURIComponent(interval)}&sat=${encodeURIComponent(sat)}&val=${encodeURIComponent(val)}`;
            stepLog(`GET ${url}`);
            await fetch(url);
            break;
          }
          case "rainbowStop": {
            const url = `${base}/fx/rainbow/stop`;
            stepLog(`GET ${url}`);
            await fetch(url);
            break;
          }
          default:
            break;
        }
        await sleep(GAP_MS);
      }
      stepLog("‚úÖ Done!");
    } catch (e) {
      console.error(e);
      stepLog(`‚ùå Error: ${e.message || e}`);
    } finally {
      setRunning(false);
    }
  }, [items, robotUrl, running]);

  /* ------------------------ UI ------------------------ */
  const palette = useMemo(
    () => [
      { type: "move",         label: "üöó Move",                color: COLORS.motion },
      { type: "beep",         label: "üîî Beep",                color: COLORS.sound  },
      { type: "note",         label: "üéµ Note",                color: COLORS.sound  },
      { type: "mary",         label: "üé∂ Mary",                color: COLORS.sound  },
      { type: "rgb",          label: "üí° RGB",                 color: COLORS.display},
      { type: "lcd",          label: "üì∫ LCD",                 color: COLORS.display},
      { type: "wait",         label: "‚è±Ô∏è Wait",                color: COLORS.control},
      { type: "rainbowStart", label: "üåà Rainbow Start",       color: COLORS.fx     },
      { type: "rainbowStop",  label: "üõë Rainbow Stop",        color: COLORS.fx     },
    ],
    []
  );

  return (
    <div style={{ minHeight: "100vh", background: "linear-gradient(135deg,#eef2ff 0%,#fdf2f8 100%)", padding: 18 }}>
      {/* Header */}
      <div style={{
        maxWidth: 1200, margin: "0 auto 14px",
        display: "flex", alignItems: "center", justifyContent: "space-between",
      }}>
        <div>
          <div style={{fontSize: 28, fontWeight: 900}}>Block-style Robot Runner</div>
          <div style={{opacity:.7, marginTop: 4}}>
            /motor, /beep, /note, /mary, /rgb, /lcd, /fx/rainbow/*
          </div>
        </div>
        <div style={{display: "flex", gap: 10, alignItems: "center"}}>
          <span style={{fontWeight: 700}}>Robot URL:</span>
          <input
            value={robotUrl}
            onChange={(e) => setRobotUrl(e.target.value)}
            placeholder="http://192.168.4.1"
            style={{
              width: 320, padding: "10px 12px", borderRadius: 12,
              border: "1px solid #e5e7eb", boxShadow: "0 2px 8px rgba(17,24,39,.05)"
            }}
          />
        </div>
      </div>

      {/* Grid */}
      <div style={{
        maxWidth: 1200, margin: "0 auto",
        display: "grid", gridTemplateColumns: "260px 1fr 360px", gap: 16
      }}>
        {/* Palette */}
        <Panel title="Palette" subtitle="Drag a block into the sequence">
          <div style={{display: "grid", gap: 10}}>
            {palette.map((p) => (
              <PaletteItem
                key={p.type}
                label={p.label}
                color={p.color}
                onDragStart={(e) => paletteDragStart(e, p.type)}
              />
            ))}
          </div>
        </Panel>

        {/* Sequence */}
        <Panel title="Sequence" subtitle="Drop blocks here and tweak values">
          <div
            ref={dropZoneRef}
            onDragOver={onDragOver}
            onDrop={onDrop}
            style={{
              minHeight: 260,
              padding: 10,
              border: "2px dashed rgba(0,0,0,.12)",
              borderRadius: 14,
              background: "rgba(255,255,255,.6)",
              boxShadow: "inset 0 2px 10px rgba(17,24,39,.05)",
            }}
          >
            {items.length === 0 ? (
              <div style={{ color: "#6b7280", padding: 10 }}>
                Drag blocks here‚Ä¶
              </div>
            ) : (
              <div style={{display:"grid", gap: 10}}>
                {items.map((it, i) => (
                  <SequenceBlock
                    key={it.id}
                    it={it}
                    index={i}
                    updateItem={updateItem}
                    moveUp={() => moveUp(i)}
                    moveDown={() => moveDown(i)}
                    remove={() => removeItem(it.id)}
                  />
                ))}
              </div>
            )}
          </div>

          {/* Controls */}
          <div style={{display:"flex", gap:10, marginTop: 12}}>
            <button
              onClick={() => setItems([])}
              disabled={running}
              style={{
                padding: "10px 14px",
                borderRadius: 12,
                border: "1px solid #e5e7eb",
                background: "#fff",
                cursor: running ? "not-allowed" : "pointer",
              }}
            >
              Clear
            </button>
            <button
              onClick={run}
              disabled={!items.length || running}
              style={{
                padding: "10px 16px",
                borderRadius: 12,
                border: "0",
                background: "linear-gradient(90deg,#22c55e,#10b981)",
                color: "#fff",
                fontWeight: 900,
                cursor: !items.length || running ? "not-allowed" : "pointer",
                boxShadow: "0 10px 18px rgba(16,185,129,.25)",
                opacity: !items.length || running ? 0.6 : 1,
              }}
            >
              {running ? "Running‚Ä¶" : "Run"}
            </button>
          </div>
        </Panel>

        {/* Log */}
        <Panel title="Log" subtitle="Requests, waits, and results">
          <div style={{
            minHeight: 260,
            background: "#0f172a",
            color: "#c7d2fe",
            borderRadius: 12,
            padding: 12,
            whiteSpace: "pre-wrap",
            fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas",
            fontSize: 13,
            boxShadow: "inset 0 2px 10px rgba(0,0,0,.3)"
          }}>
            {log}
          </div>
        </Panel>
      </div>
    </div>
  );
}

/* -------------------- Sequence block renderer -------------------- */
function SequenceBlock({ it, index, updateItem, moveUp, moveDown, remove }) {
  switch (it.type) {
    case "move":
      return (
        <BlockShell color={COLORS.motion} title="üöó Move" onUp={moveUp} onDown={moveDown} onDelete={remove}>
          <label>
            direction:
            <select
              value={it.dir}
              onChange={(e) => updateItem(it.id, { dir: e.target.value })}
              style={sel}
            >
              <option value="forward">forward</option>
              <option value="backward">backward</option>
            </select>
          </label>
          <label>
            seconds:
            <input
              type="number" step="0.1" min="0"
              value={it.seconds}
              onChange={(e) => updateItem(it.id, { seconds: e.target.value })}
              style={num}
            />
          </label>
        </BlockShell>
      );

    case "beep":
      return (
        <BlockShell color={COLORS.sound} title="üîî Beep" onUp={moveUp} onDown={moveDown} onDelete={remove}/>
      );

    case "note":
      return (
        <BlockShell color={COLORS.sound} title="üéµ Note" onUp={moveUp} onDown={moveDown} onDelete={remove}>
          <select
            value={it.name}
            onChange={(e) => updateItem(it.id, { name: e.target.value })}
            style={sel}
          >
            {NOTE_OPTIONS.map((n) => <option key={n} value={n}>{n}</option>)}
          </select>
          <label>
            beats:
            <input
              type="number" step="0.1" min="0.1"
              value={it.beats}
              onChange={(e) => updateItem(it.id, { beats: e.target.value })}
              style={num}
            />
          </label>
        </BlockShell>
      );

    case "mary":
      return (
        <BlockShell color={COLORS.sound} title="üé∂ Mary Had a Little Lamb" onUp={moveUp} onDown={moveDown} onDelete={remove}/>
      );

    case "rgb":
      return (
        <BlockShell color={COLORS.display} title="üí° RGB" onUp={moveUp} onDown={moveDown} onDelete={remove}>
          <label title="Prefer hex if set">
            hex:
            <input
              type="text"
              value={it.hex}
              onChange={(e) => updateItem(it.id, { hex: e.target.value })}
              placeholder="#RRGGBB"
              style={text}
            />
          </label>
          <span style={{opacity:.6}}>(or r,g,b)</span>
          <label>r:<input type="number" min="0" max="255" value={it.r} onChange={(e)=>updateItem(it.id,{r:e.target.value})} style={num}/></label>
          <label>g:<input type="number" min="0" max="255" value={it.g} onChange={(e)=>updateItem(it.id,{g:e.target.value})} style={num}/></label>
          <label>b:<input type="number" min="0" max="255" value={it.b} onChange={(e)=>updateItem(it.id,{b:e.target.value})} style={num}/></label>
        </BlockShell>
      );

    case "lcd":
      return (
        <BlockShell color={COLORS.display} title="üì∫ LCD" onUp={moveUp} onDown={moveDown} onDelete={remove}>
          <input
            type="text"
            value={it.msg}
            onChange={(e) => updateItem(it.id, { msg: e.target.value })}
            placeholder="Message"
            style={{...text, minWidth: 180}}
          />
          <label>
            row:
            <select
              value={it.row}
              onChange={(e) => updateItem(it.id, { row: Number(e.target.value) })}
              style={sel}
            >
              <option value={0}>0</option>
              <option value={1}>1</option>
            </select>
          </label>
          <label>
            align:
            <select
              value={it.align}
              onChange={(e) => updateItem(it.id, { align: e.target.value })}
              style={sel}
            >
              <option value="left">left</option>
              <option value="center">center</option>
              <option value="right">right</option>
            </select>
          </label>
          <label title="Backlight (prefer hex if set)">
            hex:
            <input
              type="text"
              value={it.hex}
              onChange={(e) => updateItem(it.id, { hex: e.target.value })}
              placeholder="#00AEEF"
              style={text}
            />
          </label>
          <span style={{opacity:.6}}>(or r,g,b)</span>
          <label>r:<input type="number" min="0" max="255" value={it.r} onChange={(e)=>updateItem(it.id,{r:e.target.value})} style={num}/></label>
          <label>g:<input type="number" min="0" max="255" value={it.g} onChange={(e)=>updateItem(it.id,{g:e.target.value})} style={num}/></label>
          <label>b:<input type="number" min="0" max="255" value={it.b} onChange={(e)=>updateItem(it.id,{b:e.target.value})} style={num}/></label>
        </BlockShell>
      );

    case "wait":
      return (
        <BlockShell color={COLORS.control} title="‚è±Ô∏è Wait" onUp={moveUp} onDown={moveDown} onDelete={remove}>
          <label>
            seconds:
            <input
              type="number" step="0.1" min="0"
              value={it.seconds}
              onChange={(e) => updateItem(it.id, { seconds: e.target.value })}
              style={num}
            />
          </label>
        </BlockShell>
      );

    case "rainbowStart":
      return (
        <BlockShell color={COLORS.fx} title="üåà Rainbow Start" onUp={moveUp} onDown={moveDown} onDelete={remove}>
          <label>interval (ms):
            <input type="number" min="5" max="1000" step="5"
              value={it.interval}
              onChange={(e)=>updateItem(it.id,{interval:Number(e.target.value)})}
              style={num}/>
          </label>
          <label>sat:
            <input type="number" min="0" max="255"
              value={it.sat}
              onChange={(e)=>updateItem(it.id,{sat:Number(e.target.value)})}
              style={num}/>
          </label>
          <label>val:
            <input type="number" min="0" max="255"
              value={it.val}
              onChange={(e)=>updateItem(it.id,{val:Number(e.target.value)})}
              style={num}/>
          </label>
        </BlockShell>
      );

    case "rainbowStop":
      return (
        <BlockShell color={COLORS.fx} title="üõë Rainbow Stop" onUp={moveUp} onDown={moveDown} onDelete={remove}/>
      );

    default:
      return null;
  }
}

/* Inputs */
const sel = {
  marginLeft: 6,
  padding: "8px 10px",
  border: "1px solid #e5e7eb",
  borderRadius: 10,
};
const num = {
  marginLeft: 6,
  width: 90,
  padding: "8px 10px",
  border: "1px solid #e5e7eb",
  borderRadius: 10,
};
const text = {
  marginLeft: 6,
  width: 160,
  padding: "8px 10px",
  border: "1px solid #e5e7eb",
  borderRadius: 10,
};

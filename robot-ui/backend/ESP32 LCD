// ESP32 (Arduino Core 3.x)
// SoftAP + Buzzer (beep/note/mary) + NeoPixel (/rgb) + Grove RGB LCD (/lcd)
// Grove LCD is driven with raw I2C (no external LCD libs).

#include <WiFi.h>
#include <WebServer.h>
#include <Adafruit_NeoPixel.h>
#include <Wire.h>

// ====== CONFIG: LCD init you found working in the sweep ======
#define LCD_MODE      'A'   // 'A' or 'B' (from the sweep)
#define LCD_CONTRAST  45    // 25..60 (from the sweep)

// ====== Access Point config ======
const char* AP_SSID     = "esp32-bot";
const char* AP_PASSWORD = "hackme123";  // set "" for open AP

// ====== Buzzer config ======
const int   BUZZER_PIN  = 17;     // passive buzzer + -> this pin, - -> GND
const uint8_t PWM_RES   = 8;      // LEDC resolution bits
const int   TEMPO_BPM   = 120;
const int   BEAT_MS     = 60000 / TEMPO_BPM;

// ====== NeoPixel (LED strip) config ======
#define NEO_PIN    15
#define NEO_COUNT  8
#define NEO_BRIGHT 60
Adafruit_NeoPixel strip(NEO_COUNT, NEO_PIN, NEO_GRB + NEO_KHZ800);

// ====== Grove LCD (JHD1313M1) addresses ======
#define LCD_TEXT_ADDR 0x3E   // text controller
#define LCD_RGB_ADDR  0x62   // backlight controller
const int LCD_COLS = 16;
const int LCD_ROWS = 2;

// ====== HTTP server ======
WebServer server(80);

// ---- Simple note table (common notes C3..C6)
struct NoteMap { const char* name; uint16_t freq; };
static const NoteMap NOTES[] = {
  {"C3",131},{"D3",147},{"E3",165},{"F3",175},{"G3",196},{"A3",220},{"B3",247},
  {"C4",262},{"D4",294},{"E4",330},{"F4",349},{"G4",392},{"A4",440},{"B4",494},
  {"C5",523},{"D5",587},{"E5",659},{"F5",698},{"G5",784},{"A5",880},{"B5",988},
  {"C6",1047},{"D6",1175},{"E6",1319},{"F6",1397},{"G6",1568}
};
uint16_t noteFreq(const String& name) {
  for (auto &n : NOTES) if (name.equalsIgnoreCase(n.name)) return n.freq;
  return 0;
}

// ---- Buzzer helpers ----
void toneMs(uint16_t freqHz, uint16_t durationMs) {
  if (freqHz == 0 || durationMs == 0) return;
  ledcWriteTone(BUZZER_PIN, freqHz);
  delay(durationMs);
  ledcWriteTone(BUZZER_PIN, 0);
}
void beepOnce() { toneMs(2000, 500); }
void playNoteBeats(const String& name, float beats) {
  uint16_t f = noteFreq(name);
  int dur = (int)(beats * BEAT_MS);
  if (dur < 1) dur = 1;
  if (f == 0) delay(dur);
  else        toneMs(f, dur);
}

// ---- Mary Had a Little Lamb ----
const char* MARY_NOTES[] = {
  "E4","D4","C4","D4","E4","E4","E4",
  "D4","D4","D4","E4","G4","G4",
  "E4","D4","C4","D4","E4","E4","E4","E4",
  "D4","D4","E4","D4","C4"
};
const float MARY_BEATS[] = {
  1,1,1,1,1,1,2,
  1,1,2,1,1,2,
  1,1,1,1,1,1,1,1,
  1,1,1,1,2
};
const size_t MARY_LEN = sizeof(MARY_BEATS)/sizeof(MARY_BEATS[0]);
void playMary() {
  for (size_t i = 0; i < MARY_LEN; ++i) {
    playNoteBeats(String(MARY_NOTES[i]), MARY_BEATS[i]);
    delay(int(BEAT_MS * 0.1));
  }
}

// ====== CORS helpers ======
static inline void addCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
}
void handleOptions() { addCORS(); server.send(204); }
void handleRgbOPTIONS() { handleOptions(); }
void handleLcdOPTIONS() { handleOptions(); }

// ====== Shared helpers (hex color + centering) ======
uint8_t hexNibble(char c) {
  if (c >= '0' && c <= '9') return c - '0';
  c |= 0x20; // tolower
  if (c >= 'a' && c <= 'f') return 10 + (c - 'a');
  return 0;
}
bool parseHexColor(const String& s, uint8_t& r, uint8_t& g, uint8_t& b) {
  String t = s; t.trim();
  if (t.length() == 0) return false;
  if (t[0] == '#') t.remove(0, 1);
  if (t.length() != 6) return false;
  r = (hexNibble(t[0]) << 4) | hexNibble(t[1]);
  g = (hexNibble(t[2]) << 4) | hexNibble(t[3]);
  b = (hexNibble(t[4]) << 4) | hexNibble(t[5]);
  return true;
}
String centered16(const String& s) {
  String t = s; t.trim();
  if ((int)t.length() >= LCD_COLS) return t.substring(0, LCD_COLS);
  int pad = (LCD_COLS - t.length()) / 2;
  String left="";  for (int i=0;i<pad;i++) left+=' ';
  String right=""; for (int i=0;i<(LCD_COLS - pad - t.length()); i++) right+=' ';
  return left + t + right;
}

// ====== NeoPixel helpers ======
void setAllColor(uint8_t r, uint8_t g, uint8_t b) {
  for (uint16_t i = 0; i < strip.numPixels(); i++) {
    strip.setPixelColor(i, strip.Color(r, g, b));
  }
  strip.show();
}

// ====== Grove LCD low-level (0x3E/0x62) ======
void lcdCmd(uint8_t c){
  Wire.beginTransmission(LCD_TEXT_ADDR);
  Wire.write(0x80);  // Co=1, RS=0 (command)
  Wire.write(c);
  Wire.endTransmission();
}
void lcdData(uint8_t d){
  Wire.beginTransmission(LCD_TEXT_ADDR);
  Wire.write(0x40);  // Co=0, RS=1 (data)
  Wire.write(d);
  Wire.endTransmission();
}
void lcdClear(){ lcdCmd(0x01); delay(3); }
void lcdSetCursor(uint8_t col, uint8_t row){
  static const uint8_t offs[2] = {0x00, 0x40};
  lcdCmd(0x80 | (offs[row%2] + (col%16)));
}
void lcdPrint(const String& s){ for (size_t i=0;i<s.length();++i) lcdData((uint8_t)s[i]); }

// Init sequence variants:
//   Mode 'A': 0x54 for high contrast bits
//   Mode 'B': 0x5C for high contrast bits
void lcdInitSequence(char mode, uint8_t contrast){
  // Extended instruction set (IS=1)
  lcdCmd(0x39);            // IS=1, 2-line
  lcdCmd(0x14);            // OSC freq adjust
  lcdCmd(0x70 | (contrast & 0x0F));                // contrast low bits
  if (mode=='A') lcdCmd(0x54 | ((contrast>>4)&0x03));
  else            lcdCmd(0x5C | ((contrast>>4)&0x03));
  lcdCmd(0x6C);            // Follower on
  delay(250);              // important

  // Normal instruction set
  lcdCmd(0x38);            // IS=0, 2 lines
  lcdCmd(0x0C);            // Display ON, cursor OFF
  lcdClear();
  lcdCmd(0x06);            // Entry mode: increment
}

// RGB backlight (0x62)
void rgbWrite(uint8_t reg, uint8_t val){
  Wire.beginTransmission(LCD_RGB_ADDR);
  Wire.write(reg);
  Wire.write(val);
  Wire.endTransmission();
}
void lcdSetRGB(uint8_t r, uint8_t g, uint8_t b){
  rgbWrite(0x00, 0x00);  // MODE1
  rgbWrite(0x01, 0x00);  // MODE2
  rgbWrite(0x08, 0xAA);  // LEDOUT: PWM on all channels
  rgbWrite(0x04, r);     // RED
  rgbWrite(0x03, g);     // GREEN
  rgbWrite(0x02, b);     // BLUE
}

// ---- Simple HTML UI ----
String htmlPage() {
  String ip = WiFi.softAPIP().toString();
  String page =
    "<!DOCTYPE html><html><head><meta name='viewport' content='width=device-width, initial-scale=1'/>"
    "<title>ESP32 Buzzer + RGB + LCD</title>"
    "<style>"
    "body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#f6f7fb;margin:0;padding:24px}"
    ".card{max-width:860px;margin:0 auto;background:#fff;padding:24px 28px;border-radius:16px;box-shadow:0 8px 24px rgba(0,0,0,.08)}"
    "h1{margin:0 0 8px 0;font-size:24px}"
    "p{color:#444}.row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 18px}"
    "input,select{font-size:16px;padding:10px 12px;border:1px solid #ddd;border-radius:10px}"
    "button{font-size:16px;padding:12px 18px;border:none;border-radius:10px;cursor:pointer;background:#4CAF50;color:#fff}"
    ".hint{color:#777;font-size:14px}"
    "</style></head><body><div class='card'>"
    "<h1>ESP32 (AP) — Buzzer + NeoPixel + Grove LCD</h1>"
    "<p>Connect to <b>esp32-bot</b> (pwd <code>hackme123</code>) → <code>http://" + ip + "/</code></p>"

    "<h3>1) Beep</h3>"
    "<div class='row'><form action='/beep' method='get'><button>Beep!</button></form></div>"

    "<h3>2) Play a Note</h3>"
    "<form action='/note' method='get' class='row'>"
      "<label>Note&nbsp;<input name='name' value='C4' required></label>"
      "<label>Beats&nbsp;<input name='beats' type='number' min='0.1' step='0.1' value='1' required></label>"
      "<button>Play</button>"
    "</form>"

    "<h3>3) Mary Had a Little Lamb</h3>"
    "<div class='row'><form action='/mary' method='get'><button>Play Mary</button></form></div>"

    "<h3>4) NeoPixel RGB (POST /rgb)</h3>"
    "<p class='hint'>Set with: <code>POST /rgb?r=255&g=0&b=128</code> or <code>POST /rgb?hex=%23FF0080</code> (or body \"#FF0080\").</p>"

    "<h3>5) Grove LCD (GET/POST /lcd)</h3>"
    "<p class='hint'>Params: <code>msg=...</code> (required). Optional backlight <code>r,g,b</code> or <code>hex=%23RRGGBB</code>. Optional <code>row</code> and <code>align</code>.</p>"
    "<form action='/lcd' method='post' class='row'>"
      "<label>Text&nbsp;<input name='msg' placeholder='Hello, Grove LCD!' required></label>"
      "<label>Row&nbsp;<input name='row' type='number' min='0' max='1' value='0'></label>"
      "<label>Align&nbsp;<select name='align'><option>center</option><option>left</option><option>right</option></select></label>"
      "<label>Hex&nbsp;<input name='hex' placeholder='#00AEEF'></label>"
      "<button>Show</button>"
    "</form>"

    "<p class='hint'>I2C: SDA=21, SCL=22. LCD text=0x3E, RGB=0x62. NeoPixel on GPIO 15.</p>"
    "</div></body></html>";
  return page;
}

// ---- Web Handlers ----
void handleRoot() { server.send(200, "text/html", htmlPage()); }

void handleBeepGET() { beepOnce(); handleRoot(); }

void handleNoteGET() {
  String name = server.hasArg("name") ? server.arg("name") : "C4";
  float beats = server.hasArg("beats") ? server.arg("beats").toFloat() : 1.0f;
  if (beats <= 0) beats = 0.25f;
  playNoteBeats(name, beats); handleRoot();
}

void handleMaryGET() { playMary(); handleRoot(); }

// --- /rgb: GET/POST unified handler (NeoPixel strip) ---
void handleRgbAny() {
  addCORS();

  uint8_t r = 0, g = 0, b = 0;
  bool ok = false;

  // Query string first
  if (server.hasArg("hex")) {
    ok = parseHexColor(server.arg("hex"), r, g, b);
  } else if (server.hasArg("r") || server.hasArg("g") || server.hasArg("b")) {
    r = constrain(server.arg("r").toInt(), 0, 255);
    g = constrain(server.arg("g").toInt(), 0, 255);
    b = constrain(server.arg("b").toInt(), 0, 255);
    ok = true;
  }

  // Body fallbacks
  if (!ok && server.method() == HTTP_POST) {
    String ct = server.header("Content-Type");
    ct.toLowerCase();

    if (ct.indexOf("application/x-www-form-urlencoded") >= 0) {
      if (server.hasArg("hex")) ok = parseHexColor(server.arg("hex"), r, g, b);
      else if (server.hasArg("r") || server.hasArg("g") || server.hasArg("b")) {
        r = constrain(server.arg("r").toInt(), 0, 255);
        g = constrain(server.arg("g").toInt(), 0, 255);
        b = constrain(server.arg("b").toInt(), 0, 255);
        ok = true;
      }
    } else if (ct.indexOf("text/plain") >= 0) {
      String body = server.arg("plain"); body.trim();
      if (body.startsWith("#") || body.length() == 6) {
        ok = parseHexColor(body, r, g, b);
      } else if (body.length() > 0) {
        int ri = body.indexOf("r="), gi = body.indexOf("g="), bi = body.indexOf("b=");
        if (ri >= 0) r = constrain(body.substring(ri+2).toInt(), 0, 255);
        if (gi >= 0) g = constrain(body.substring(gi+2).toInt(), 0, 255);
        if (bi >= 0) b = constrain(body.substring(bi+2).toInt(), 0, 255);
        ok = (ri >= 0 || gi >= 0 || bi >= 0);
      }
    } else if (ct.indexOf("application/json") >= 0) {
      String body = server.arg("plain"); body.trim();
      auto getInt = [&](const char* key, int& out)->bool{
        String k = "\"" + String(key) + "\":";
        int i = body.indexOf(k);
        if (i < 0) return false;
        i += k.length();
        while (i < (int)body.length() && (body[i]==' '||body[i]=='\t')) i++;
        int j = i;
        while (j < (int)body.length() && isDigit(body[j])) j++;
        out = body.substring(i,j).toInt();
        return true;
      };
      int ri=-1, gi=-1, bi=-1;
      int hx = body.indexOf("\"hex\"");
      if (hx >= 0) {
        int q1 = body.indexOf('"', body.indexOf(':', hx)+1);
        int q2 = (q1>=0) ? body.indexOf('"', q1+1) : -1;
        if (q1>=0 && q2>q1) {
          String h = body.substring(q1+1, q2);
          ok = parseHexColor(h, r, g, b);
        }
      }
      if (!ok) {
        bool any = false;
        if (getInt("r", ri)) { r = constrain(ri,0,255); any = true; }
        if (getInt("g", gi)) { g = constrain(gi,0,255); any = true; }
        if (getInt("b", bi)) { b = constrain(bi,0,255); any = true; }
        ok = any;
      }
    }
  }

  if (!ok) {
    Serial.println("RGB: missing/invalid params");
    server.send(200, "text/html", htmlPage());
    return;
  }

  setAllColor(r, g, b);
  Serial.printf("RGB set to (%u,%u,%u)\n", r, g, b);
  server.send(200, "text/html", htmlPage());
}

// --- /lcd: GET/POST unified handler (Grove LCD) ---
void handleLcdAny() {
  addCORS();

  String msg; bool ok=false;
  int row = 0;
  String align = "center";
  uint8_t cr=0, cg=128, cb=255; // default cyan-ish
  bool hasColor = false;

  // Query/form args
  if (server.hasArg("msg")) { msg = server.arg("msg"); ok = true; }
  if (server.hasArg("row")) row = constrain(server.arg("row").toInt(), 0, 1);
  if (server.hasArg("align")) { String a = server.arg("align"); a.toLowerCase(); if (a=="left"||a=="right"||a=="center") align = a; }
  if (server.hasArg("hex")) { hasColor = parseHexColor(server.arg("hex"), cr,cg,cb); }
  if (!hasColor && (server.hasArg("r")||server.hasArg("g")||server.hasArg("b"))) {
    cr = constrain(server.arg("r").toInt(),0,255);
    cg = constrain(server.arg("g").toInt(),0,255);
    cb = constrain(server.arg("b").toInt(),0,255);
    hasColor = true;
  }

  // text/plain fallback
  if (!ok && server.method()==HTTP_POST) {
    String body = server.arg("plain"); body.trim();
    if (body.length()>0) { msg = body; ok = true; }
  }

  if (!ok) { server.send(400, "application/json", "{\"error\":\"invalid params\"}"); return; }

  if (hasColor) lcdSetRGB(cr,cg,cb);

  // Render text
  if (msg.indexOf('\n') >= 0) {
    String l1 = msg.substring(0, msg.indexOf('\n'));
    String l2 = msg.substring(msg.indexOf('\n') + 1);
    lcdClear();
    lcdSetCursor(0,0); lcdPrint(centered16(l1));
    lcdSetCursor(0,1); lcdPrint(centered16(l2));
  } else {
    if (align == "center") {
      lcdClear();
      lcdSetCursor(0,row); lcdPrint(centered16(msg));
    } else {
      String t = msg; t.trim(); if ((int)t.length() > LCD_COLS) t = t.substring(0, LCD_COLS);
      int col = (align=="right") ? (LCD_COLS - t.length()) : 0;
      // clear the row then print
      lcdSetCursor(0,row); for (int i=0;i<LCD_COLS;i++) lcdData(' ');
      lcdSetCursor(col,row); lcdPrint(t);
    }
  }

  server.send(200, "text/html", htmlPage());
}

void setup() {
  Serial.begin(115200);
  delay(200);

  // Buzzer PWM (Core 3.x)
  pinMode(BUZZER_PIN, OUTPUT);
  ledcAttach(BUZZER_PIN, 2000, PWM_RES);

  // NeoPixel init
  strip.begin();
  strip.setBrightness(NEO_BRIGHT);
  strip.show(); // all off

  // I2C init (standard ESP32 pins)
  Wire.begin(21, 22);
  Wire.setClock(100000);

  // Grove LCD init (use the working mode/contrast you found)
  lcdInitSequence(LCD_MODE, LCD_CONTRAST);
  lcdSetRGB(0, 128, 255); // cyan splash
  lcdClear();
  lcdSetCursor(0,0); lcdPrint(centered16("Grove RGB LCD"));
  lcdSetCursor(0,1); lcdPrint(centered16("AP ready"));

  // Start SoftAP (default IP 192.168.4.1)
  WiFi.mode(WIFI_AP);
  bool ok = WiFi.softAP(AP_SSID, AP_PASSWORD);
  Serial.printf("AP start: %s\n", ok ? "OK" : "FAILED");
  Serial.print("SSID: "); Serial.println(AP_SSID);
  Serial.print("AP IP: "); Serial.println(WiFi.softAPIP());

  // Routes
  server.on("/",     HTTP_GET,      handleRoot);
  server.on("/beep", HTTP_GET,      handleBeepGET);
  server.on("/note", HTTP_GET,      handleNoteGET);
  server.on("/mary", HTTP_GET,      handleMaryGET);

  server.on("/rgb",  HTTP_OPTIONS,  handleRgbOPTIONS);
  server.on("/rgb",  HTTP_ANY,      handleRgbAny);   // GET + POST

  server.on("/lcd",  HTTP_OPTIONS,  handleLcdOPTIONS);
  server.on("/lcd",  HTTP_ANY,      handleLcdAny);   // GET + POST

  server.begin();
  Serial.println("HTTP server started");
}

void loop() {
  server.handleClient();
}
